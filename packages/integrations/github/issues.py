"""
GitHub Issues Operations

Provides issue management operations:
- Create issues from agent output
- Update issue status
- Add comments
- Link related issues
- Search issues
"""

from typing import Any, Dict, List, Optional

from .client import GitHubClient


class IssueOperations:
    """
    GitHub Issues operations

    Handles all issue-related operations including creation,
    updates, comments, labels, and searching.
    """

    def __init__(self, client: GitHubClient):
        """
        Initialize issue operations

        Args:
            client: GitHubClient instance
        """
        self.client = client

    async def create_issue(
        self,
        owner: str,
        repo: str,
        title: str,
        body: Optional[str] = None,
        assignees: Optional[List[str]] = None,
        labels: Optional[List[str]] = None,
        milestone: Optional[int] = None,
    ) -> Dict[str, Any]:
        """
        Create a new issue

        Args:
            owner: Repository owner
            repo: Repository name
            title: Issue title
            body: Issue body (markdown)
            assignees: List of usernames to assign
            labels: List of label names
            milestone: Milestone number

        Returns:
            Created issue data
        """
        endpoint = f"/repos/{owner}/{repo}/issues"
        payload = {"title": title}

        if body:
            payload["body"] = body
        if assignees:
            payload["assignees"] = assignees
        if labels:
            payload["labels"] = labels
        if milestone:
            payload["milestone"] = milestone

        return await self.client.post(endpoint, json=payload)

    async def create_issue_from_agent_output(
        self,
        owner: str,
        repo: str,
        agent_output: Dict[str, Any],
        template: Optional[str] = None,
    ) -> Dict[str, Any]:
        """
        Create issue from agent output

        Args:
            owner: Repository owner
            repo: Repository name
            agent_output: Agent output containing issue details
            template: Optional markdown template

        Returns:
            Created issue data
        """
        # Extract issue details from agent output
        title = agent_output.get("title", "Agent-generated issue")
        description = agent_output.get("description", "")
        findings = agent_output.get("findings", [])
        recommendations = agent_output.get("recommendations", [])
        severity = agent_output.get("severity", "medium")

        # Build issue body
        if template:
            body = template.format(**agent_output)
        else:
            body = self._build_issue_body(
                description=description,
                findings=findings,
                recommendations=recommendations,
                severity=severity,
                metadata=agent_output.get("metadata", {}),
            )

        # Extract labels from severity and tags
        labels = [f"severity:{severity}"]
        if "tags" in agent_output:
            labels.extend(agent_output["tags"])

        return await self.create_issue(
            owner=owner,
            repo=repo,
            title=title,
            body=body,
            labels=labels,
        )

    def _build_issue_body(
        self,
        description: str,
        findings: List[Dict[str, Any]],
        recommendations: List[str],
        severity: str,
        metadata: Dict[str, Any],
    ) -> str:
        """Build formatted issue body"""
        lines = [
            "## Description",
            description,
            "",
            f"**Severity:** {severity.upper()}",
            "",
        ]

        if findings:
            lines.append("## Findings")
            for i, finding in enumerate(findings, 1):
                lines.append(f"\n### Finding {i}")
                if isinstance(finding, dict):
                    lines.append(f"**Location:** {finding.get('location', 'N/A')}")
                    lines.append(f"**Issue:** {finding.get('issue', 'N/A')}")
                    if "code" in finding:
                        lines.append(f"\n```\n{finding['code']}\n```")
                else:
                    lines.append(str(finding))
            lines.append("")

        if recommendations:
            lines.append("## Recommendations")
            for rec in recommendations:
                lines.append(f"- {rec}")
            lines.append("")

        if metadata:
            lines.append("## Metadata")
            for key, value in metadata.items():
                lines.append(f"- **{key}:** {value}")

        lines.append("\n---")
        lines.append("*Generated by AI Agent*")

        return "\n".join(lines)

    async def update_issue(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        title: Optional[str] = None,
        body: Optional[str] = None,
        state: Optional[str] = None,
        labels: Optional[List[str]] = None,
        assignees: Optional[List[str]] = None,
    ) -> Dict[str, Any]:
        """
        Update an existing issue

        Args:
            owner: Repository owner
            repo: Repository name
            issue_number: Issue number
            title: New title
            body: New body
            state: New state ("open" or "closed")
            labels: New labels list
            assignees: New assignees list

        Returns:
            Updated issue data
        """
        endpoint = f"/repos/{owner}/{repo}/issues/{issue_number}"
        payload = {}

        if title is not None:
            payload["title"] = title
        if body is not None:
            payload["body"] = body
        if state is not None:
            payload["state"] = state
        if labels is not None:
            payload["labels"] = labels
        if assignees is not None:
            payload["assignees"] = assignees

        return await self.client.patch(endpoint, json=payload)

    async def close_issue(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        comment: Optional[str] = None,
    ) -> Dict[str, Any]:
        """
        Close an issue

        Args:
            owner: Repository owner
            repo: Repository name
            issue_number: Issue number
            comment: Optional closing comment

        Returns:
            Updated issue data
        """
        if comment:
            await self.add_comment(owner, repo, issue_number, comment)

        return await self.update_issue(
            owner=owner,
            repo=repo,
            issue_number=issue_number,
            state="closed",
        )

    async def add_comment(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        body: str,
    ) -> Dict[str, Any]:
        """
        Add a comment to an issue

        Args:
            owner: Repository owner
            repo: Repository name
            issue_number: Issue number
            body: Comment body (markdown)

        Returns:
            Created comment data
        """
        endpoint = f"/repos/{owner}/{repo}/issues/{issue_number}/comments"
        return await self.client.post(endpoint, json={"body": body})

    async def get_issue(
        self,
        owner: str,
        repo: str,
        issue_number: int,
    ) -> Dict[str, Any]:
        """
        Get issue details

        Args:
            owner: Repository owner
            repo: Repository name
            issue_number: Issue number

        Returns:
            Issue data
        """
        endpoint = f"/repos/{owner}/{repo}/issues/{issue_number}"
        return await self.client.get(endpoint)

    async def list_issues(
        self,
        owner: str,
        repo: str,
        state: str = "open",
        labels: Optional[List[str]] = None,
        assignee: Optional[str] = None,
        creator: Optional[str] = None,
        mentioned: Optional[str] = None,
        per_page: int = 30,
    ) -> List[Dict[str, Any]]:
        """
        List repository issues

        Args:
            owner: Repository owner
            repo: Repository name
            state: Issue state ("open", "closed", "all")
            labels: Filter by labels (comma-separated)
            assignee: Filter by assignee
            creator: Filter by creator
            mentioned: Filter by mentioned user
            per_page: Results per page

        Returns:
            List of issues
        """
        endpoint = f"/repos/{owner}/{repo}/issues"
        params = {"state": state, "per_page": per_page}

        if labels:
            params["labels"] = ",".join(labels)
        if assignee:
            params["assignee"] = assignee
        if creator:
            params["creator"] = creator
        if mentioned:
            params["mentioned"] = mentioned

        return await self.client.paginate(endpoint, params=params, per_page=per_page)

    async def search_issues(
        self,
        query: str,
        sort: Optional[str] = None,
        order: str = "desc",
        per_page: int = 30,
    ) -> Dict[str, Any]:
        """
        Search issues across GitHub

        Args:
            query: Search query (GitHub search syntax)
            sort: Sort field ("comments", "reactions", "created", "updated")
            order: Sort order ("asc" or "desc")
            per_page: Results per page

        Returns:
            Search results with items and metadata
        """
        endpoint = "/search/issues"
        params = {"q": query, "order": order, "per_page": per_page}

        if sort:
            params["sort"] = sort

        return await self.client.get(endpoint, params=params)

    async def add_labels(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        labels: List[str],
    ) -> List[Dict[str, Any]]:
        """
        Add labels to an issue

        Args:
            owner: Repository owner
            repo: Repository name
            issue_number: Issue number
            labels: List of label names

        Returns:
            Updated labels list
        """
        endpoint = f"/repos/{owner}/{repo}/issues/{issue_number}/labels"
        return await self.client.post(endpoint, json={"labels": labels})

    async def remove_label(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        label: str,
    ) -> Dict[str, Any]:
        """
        Remove a label from an issue

        Args:
            owner: Repository owner
            repo: Repository name
            issue_number: Issue number
            label: Label name to remove

        Returns:
            Empty dict on success
        """
        endpoint = f"/repos/{owner}/{repo}/issues/{issue_number}/labels/{label}"
        return await self.client.delete(endpoint)

    async def link_issues(
        self,
        owner: str,
        repo: str,
        issue_number: int,
        related_issues: List[int],
        relationship: str = "related to",
    ) -> Dict[str, Any]:
        """
        Link related issues by adding a comment with references

        Args:
            owner: Repository owner
            repo: Repository name
            issue_number: Issue number
            related_issues: List of related issue numbers
            relationship: Relationship type (e.g., "related to", "blocks", "depends on")

        Returns:
            Created comment data
        """
        references = [f"#{num}" for num in related_issues]
        body = f"This issue is {relationship} {', '.join(references)}"

        return await self.add_comment(owner, repo, issue_number, body)

    async def get_issue_timeline(
        self,
        owner: str,
        repo: str,
        issue_number: int,
    ) -> List[Dict[str, Any]]:
        """
        Get issue timeline events

        Args:
            owner: Repository owner
            repo: Repository name
            issue_number: Issue number

        Returns:
            List of timeline events
        """
        endpoint = f"/repos/{owner}/{repo}/issues/{issue_number}/timeline"
        headers = {"Accept": "application/vnd.github.mockingbird-preview+json"}

        # Use client with custom headers
        return await self.client.paginate(endpoint)
